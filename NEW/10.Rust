nce
INSTALL RUST (LINUX/MAC)
-------------------------
>> curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

EXTENSION
----------
.rs

COMPILE AND RUN PROGRAM (Without Cargo)
----------------------------
compile :

rustrc [filename]
eg:- rustc main.rs

Run :

./main


COMPRESS AND COMPILED FILE (Without Cargo)
-------------------------------------------
>> rustc main.rs -C opt-level=z -C lto -C codegen-units=1 -C strip=debuginfo -o myOutput
>> strip myOutpput


RUST TOOLS (Cargo and Fmt)
--------------------------
cargo - initialize project, track dependencies ...etc
rust Fmt - automatically format Rust code

  Initialize a project with cargo
  -------------------------------
  >> cargo new [project name] eg: cargo new myProject1

  Build a program (compile) with cargo
  ------------------------------------
  >> cargo build 

  Compile and Run (Automatically) with cargo
  -------------------------------------------
  >> cargo run

  Cargo check for errors
  -----------------------
  >> cargo check

  Format Rust code with rustfmt
  -----------------------------
  >> rustfmt ./src/main.rs



HELLO WORLD
-----------
  fn main(){
      println!("Hello world");
  }


VARIABLES
-----------
      fn main(){
        let x = 5; //immutable variable (value cannot be changed) immutable by default
        println!("the value of x is {}",x); //output : the value of x is 5
        
        let mut y = 10; //mutable value (value can be changed)
        println!("the value of y is {}",y); //output : the value of y is 10
        y = 200; //changing value of immutable variable y
        println!("the new value of y is {}",y); //output : the new value of y is 200
    
    
        //shadowing
        let g =20;
    
        //interior scope : whatever variables assigned inside this scope wont affect the variable outside this
        {
            let g = 29; //value only changes for this scope
            println!("value of g is {}",g); //output : value of g is 29
        }
    
        println!("the value of g is {}",g);//output : the value of g is 20
    
        //constant value (cannot reassign, cannot redefine)
        const SECONDS_IN_MINUTE:u32 = 60; //data type is compulsory
        println!("seconds in 1 minute : {}",SECONDS_IN_MINUTE); //output: seconds in 1 minute : 60
    }


DATATYPES - Primitive-
-----------------------
Scalar data type  : eg: int,char,boolean (single values)
compound data type : eg:- array,tuple (multiple values)

Scalar
------
    Integer
    -------
    let x:i32 = -120 (i = signed integer(can have -ve and +ve numbers) 32 = 32 bit (-2,147,483,648$ to 2,147,483,647))
    let y:u32 = 888999 (u = unsigned integer (can only have +ve numbers) 32 = 32 bit(0 to 134,294,967,295))

    type               Range
    ------------------------------------
    u8          :    0 -> 255
    u16         :    0 -> 65,535
    u32         :    0 -> 4,294,967,295
    u64         :    0 -> 18,446,744,073,709,551,615

    i8          :   -128 -> 127 
    i16         :   -32,768 -> 32,767
    i32         :   -2,147,483,648 -> 2,147,483,647
    i64         :   -9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807


  Floating-points (Decimals)
  --------------------------
  let x:f32 = 20.89 (can be positive and negative)

  type               Range
  ------------------------------------
  f32          :    7 decimal digits (single precision)
  f64          :    15 decimal digits (double precision)  --default for rust--



  Boolean
  -------
  let verified:bool = false;
  let is_alive:bool = true;
  let is_true:bool = 1; //same as true
  let is_false:bool = 0; //same as false



  Char
  ----
  let a_charector:char = 'x'; (single quotes)

Compound
---------
    Tuple (sequence of elements - immutable (by default) and fixed length)
    -----------------------------------------------------------
    let tuple1 = (1,'x',false,2.1); //immutable tuple
    println!("{}",tuple1.2); //accessing the element of tuple by  index number

    let mut tuple2 = (8,'c',true,3.141); //mutable tuple with datatypes and size specified
    tuple2.1 = 'g'; //modifying the element (only with same data type)
    println!("{}",tuple2.1); //accessing the element of tuple by  index number


    Array (sequence of elements - same datatype, immutable (by default) and fixed length)
    --------------------------------------------------------------------------------------
    let array1 = [1,2,3,4,5];
    println!("{}",array1[2]); //access element in array

    let mut array2:[i8;5] = [2,4,6,8,0]; //mutable array with datatype and size specified
    array2[1] = 7; //modifying the element
    println!("{}",array2[1]); //access element in array


    Vector (sequence of elements - same datatype, immutable (by default)
    --------------------------------------------------------------------
    let mut colors = vec!["green","pink","red","blue"]; //immutable vector
    colors[0]="orange"; //modify element
    colors.push(21); //add new element
    colors.remove(0); //remove element by index number
    colors.pop(); //remove the last element 
    
    println!("{}",colors[0]); //access elements of vector
    println!("length of vecror : {}",colors.len()); //get the size of vector

INPUT
------

    //collect input String
    -----------------------

    use std::io;
    
    fn main(){
        println!("Enter your name"); //label for input
        let mut name = String::new();
        io::stdin().read_line(&mut name).expect("Error while collecting Input"); //collect input into variable 'name' as string
        println!("Hello {}",name);
    }


  //collect input Integer
 -------------------------

  use std::io;

  fn main(){
      println!("Enter a number : ");
      let mut num1 = String::new();
      io::stdin().read_line(&mut num1).expect("Error while collecting number 1");
      let num1_convert_to_int:i32 = num1.trim().parse().expect("Failed to parse num1 to integer"); //convert string to integer
  
      println!("Enter another number : ");
      let mut num2 = String::new();
      io::stdin().read_line(&mut num2).expect("Error while collecting number 2");
      let num2_convert_to_int:i32 = num2.trim().parse().expect("Failed to parse num2 to Integer"); //convert string to integer
  
      println!("\n\nthe sum of {} and {} is {}",num1,num2,num1_convert_to_int+num2_convert_to_int);
  
  }


ARITHMETIC OPERATORS (With different data types)
------------------------------------------------
fn main(){
    let num1:i32 = 28;
    let num2:f32 = 44.98;

    let sum:f32 = num1 as f32 + num2; //converting num1 to f32
    let substraction:i32 = num1 - num2 as i32; //converting num2 to i32
    let multiplication:f32 = num1 as f32 * num2; //converting num1 to f32
    let division:f64 = num1 as f64 / num2 as f64; //converting num2 and num1 to f64

    println!("sum : {}",sum);
    println!("substraction : {}",substraction);
    println!("multiplication : {}",multiplication);
    println!("division : {}",division);
}

CONDITION,COMPOUND CONDITION AND CONTROL FLOW
---------------------------------------------
condition : true or false
compound condition : && and || 
control flow : if ,else if and else
conditional operators : >,<,>=,<=,==,!=

use std::io;

fn main(){
    println!("Enter a number : "); //input label
    let mut number = String::new(); //input storing variable
    io::stdin().read_line(&mut number).expect("Unable to read number"); //make an input
    let string_to_number:i32 = number.trim().parse().expect("Unable to parse to number"); //convert string to number

    //check number is positive or negative with if else
    if string_to_number>0 {
        println!("The number is positive");
    }else if string_to_number<0 {
        println!("The number is negative")
    }
    else{
        println!("The number is zero");
    }
}

FUNCTIONS
---------

simple function
---------------
    fn show_message(){
        println!("Hello world");
    }
    
    fn main(){
        show_message();
    }

function with parameters
------------------------
     //with integer

    fn find_sum(num1:i32,num2:i32){
        println!("sum is : {}",num1+num2);
    }
    
    fn main(){
        find_sum(6,8);
    }

    //with string (str)

    fn greet(name:&str){
        println!("Hello {}",name);
    }
    
    fn main(){
        greet("John");
    }

function with return
--------------------
    fn add_numbers(num1:i32,num2:i32)->i32{ //specify the return type
        num1+num2 //returns the result
    }
    
    fn main(){
        println!("{}",add_numbers(2,4));
    }

or

    fn add_numbers(num1:i32,num2:i32)->i32{ //specify the return type
        return num1+num2; //returns the result
    }
    
    fn main(){
        println!("{}",add_numbers(2,4));
    }

TERENARY OPERATOR
------------------

fn main(){
    let word = "color";

    let result = {
        if word == "fruit"{
            "my favourite fruit is apple"  //dont use ; for returning value
        }
        else if word == "color"{
            "my favourite color is green"  //dont use ; for returning value
        }
        else {
            "no value"  //dont use ; for returning value
        }
    };

    println!("{}",result);
}


https://youtu.be/APrANyLHCtQ?list=PLzMcBGfZo4-nyLTlSRBvo0zjSnCnqjHYQ
playlist : https://www.youtube.com/playlist?list=PLzMcBGfZo4-nyLTlSRBvo0zjSnCnqjHYQ
